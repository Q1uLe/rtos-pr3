# Практическая работа №3
# Демонстрация работы с процессами в POSIX
## Информация о проекте
- **ИМЯ**: SHARIPOV RENAT, **ID**: 23К0210
- **СРОК**: 10/07/2025
- **Курс**Вычислительные системы реального времени
## Назначение программы
Программа демонстрирует работу с процессами в POSIX-системах.
Создаёт дерево процессов: родительский процесс порождает 
дочерний и управляет его выполнением
## Структура проекта
```
project/
├── prog1.c # Главная программа (родительский процесс)
├── process.c # Дочерняя программа
├── Makefile # Сборочный файл
└── README.md # Документация
```
## Логика программы
### Основной алгоритм:
1. **Родительский процесс (prog1)**:
    - Запрашивает имя пользователя
    - Создает дочерний процесс через `fork()`
    - Ожидает завершения дочернего процесса `waitpid()`
    - Анализирует статус завершения
2. **Дочерний процесс (process)**
    - Запускается через `execl("./process", ...)`
    - Выполняет имитацию работы (цикл с задержками)
    - Завершается с кодом возврата
### Обработка сигналов:
- **SIGINT (Ctrl+C)** - корректное завершение с кодом 130
- **SIGTERM** - завершение по сигналу с кодом 143

## Используемые системные вызовы и функции 
| Название | Назначение |
|-----------------|------------|
|`fork()`|Создание дочернего процесса|
|`execl()`|Загрузка новой программы|
|`waitpid()`|Ожидание завершения процесса|
|`getpid()`|Получение PID текущего процесса|
|`getppid()`|Получение PID родительского процесса|
|`signal()`|Установка обработчика сигналов|
|`WIFEXITED()`|Проверка нормального завершения|
|`WEXITSTATUS()`|Получение кода возврата|
|`WIFSIGNALED()`|Проверка завершения по сигналу|
|`WTERMSIG()`|Получение номера сигнала|
|`exit()`|Завершение процесса|
|`perror()`|Вывод сообщения об ошибке|
|`scanf()`|Ввод данных с клавиатуры|
|`printf()`|Вывод данных на консоль|
## Инструкция по сборке и запуску
### Сборка проект
```bash
make
```
### Запуск
```bash
./prog1
```
### Очистка
```bash
make clean
```
## Решенные проблемы
### **Проблема 1: некорректное завершение по Ctrl+C**
#### **Симптом**: при нажатии Ctrl+C программа завершалась с кодом 0
#### **Решение**: Добавлен вызов `exit(130)` в обработчик сигнала SIGINT

## Анализ работы программы
### Дерево процессов
```
prog1 (родительский процесс)
└── process (дочерний процесс) 
```
### Коды завершения
- 0 - успешное завершение
- 1 - ошибка ввода/выполнения
- 130 - завершение по SIGINT(Ctrl+C)
- 143 - завершение по SIGTERM

## Тестирование сигналов
### Тест SIGTERM
```bash
# В одном терминале:
./prog1
# В другом терминале:
kill <PID_prog1>
```
### Тест SIGINT
```bash
./prog1
# Нажать Ctrl+C во время выполнения
```

